## C#基础篇

- 请简述拆箱和装箱

> 答：
> 装箱操作：
> 值类型隐式转换为object类型或由此值类型实现的任何接口类型的过程。
> 1.在堆中开辟内存空间。
> 2.将值类型的数据复制到堆中。
> 3.返回堆中新分配对象的地址。
> 拆箱操作：
> object类型显示转换为值类型或从接口类型到实现该接口值类型的过程。
> 1.判断给定类型是否是装箱时的类型。
> 2.返回已装箱实例中属于原值类型字段的地址。

- C#中，string str = null 与 string str = ""，说明区别。

> 答：
> string str = "" 初始化对象分配空间。
> string str = null 表示一个空引用,没有占用空间。

- ref与out关键字

> 答：
> ref 关键字使参数按引用传递。其效果是，当控制权传递回调用方法时，在方法中对参数所做的任何更改都将反映在该变量中。若要使用 ref 参数，则方法定义和调用方法都必须显式使用 ref 关键字。
> out 关键字会导致参数通过引用来传递。这与 ref 关键字类似，不同之处在于 ref 要求变量必须在传递之前进行初始化。若要使用 out 参数，方法定义和调用方法都必须显式使用 out 关键字。

- 什么是序列化？

> 答：
> 序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。

- sealed 修饰符有什么特点

> 答：
> \1) sealed 修饰符可以应用于类、实例方法和属性。密封类不能被继承。密封方法会重写基类中的方法，但其本身不能在任何派生类中进一步重写。当应用于方法或属性时，sealed 修饰符必须始终与 override一起使用。
> \2) 将密封类用作基类或将 abstract 修饰符与密封类一起使用是错误的。
> \3) 结构是隐式密封的；因此它们不能被继承。

- class和struct的异同

> 答：
> 相同点：
> \1) 语法类似。
> 不同点：
> \1) class是引用类型，继承自System.Object类; struct是值类型，继承自System.ValueType类，因此不具多态性。但是注意，System.ValueType是个引用类型。
> \2) 从职能观点来看，class表现为行为; 而struct常用于存储数据。
> \3) class支持继承，可以继承自类和接口; 而struct没有继承性，struct不能从class继承，也不能作为class的基类，但struct支持接口继承。
> \4) 实例化时，class要使用new关键字; 而struct可以不使用new关键字，struct在声明时就进行了初始化过程，所有的成员变量均默认为0或null。

- 如何选择结构还是类。

> 答：
> \1) 堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些。
> \2) 结构表示如点、矩形和颜色这样的轻量对象。例如，如果声明一个含有 1000 个点对象的数组，则将为引用每个对象分配附加的内存。在此情况下，结构的成本较低。
> \3) 在表现抽象和多级别的对象层次时，类是最好的选择。
> \4) 大多数情况下该类型只是一些数据时，结构时最佳的选择。

- 抽象类（abstract class）和接口（interface）的区别。

> 答：
> 抽象类：
> \1) 抽象方法只作声明，而不包含实现，可以看成是没有实现体的虚方法。
> \2) 抽象类不能被实例化。
> \3) 抽象类可以但不是必须有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类。
> \4) 具体派生类必须覆盖基类的抽象方法。
> \5) 抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们。
> 接口：
> \1) 接口不能被实例化。
> \2) 接口只能包含方法声明。
> \3) 接口的成员包括方法、属性、索引器、事件。
> \4) 接口中不能包含常量、字段(域)、构造函数、析构函数、静态成员。
> \5) 接口中的所有成员默认为public，因此接口中不能有private修饰符。
> \6) 派生类必须实现接口的所有成员。
> \7) 一个类可以直接实现多个接口，接口之间用逗号隔开。
> \8) 一个接口可以有多个父接口，实现该接口的类必须实现所有父接口中的所有成员。
> 抽象类和接口的异同：
> 相同点：
> \1) 都可以被继承。
> \2) 都不能被实例化。
> \3) 都可以包含方法声明。
> \4) 派生类必须实现未实现的方法。
> 区别：
> \1) 抽象基类可以定义字段、属性、方法实现。接口只能定义属性、索引器、事件、和方法声明，不能包含字段。
> \2) 抽象类是一个不完整的类，需要进一步细化，而接口是一个行为规范。微软的自定义接口总是后带able字段，证明其是表述一类“我能做。。。”。
> \3) 接口可以被多重实现，抽象类只能被单一继承。
> \4) 抽象类更多的是定义在一系列紧密相关的类间，而接口大多数是关系疏松但都实现某一功能的类中。
> \5) 抽象类是从一系列相关对象中抽象出来的概念，因此反映的是事物的内部共性；接口是为了满足外部调用而定义的一个功能约定，因此反映的是事物的外部特性。
> \6) 接口基本上不具备继承的任何具体特点,它仅仅承诺了能够调用的方法。
> \7) 接口可以用于支持回调,而继承并不具备这个特点。
> \8) 抽象类实现的具体方法默认为虚的，但实现接口的类中的接口方法却默认为非虚的，当然您也可以声明为虚的。
> \9) 如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法。

- 什么是强类型。

> 答：
> 为所有变量指定数据类型称为“强类型”。C#是强类型语言。

- 什么是托管代码。

> 答：
> 使用基于公共语言运行库的语言编译器开发的代码称为托管代码；托管代码具有许多优点，例如：跨语言集成、跨语言异常处理、增强的安全性、版本控制和部署支持、简化的组件交互模型、调试和分析服务等。

- 什么是CLR？

> 答：
> CLR：公共语言运行库 Common Language Runtime。是一个运行时环境，它负责资源管理（内存分配和垃圾收集），并保证应用和底层操作系统之间必要的分离。

- 什么是委托？

> 答：
> \1) 委托是一种引用方法的类型。
> \2) 委托类似于 C++ 函数指针，但它是类型安全的。
> \3) 委托允许将方法作为参数进行传递。
> \4) 委托可用于定义回调方法。

- 值类型和引用类型的区别。

> 答：
> \1) 值类型通常被分配在栈上，它的变量直接包含变量的实例，使用效率比较高。
> \2) 引用类型分配在托管堆上，引用类型的变量通常包含一个指向实例的指针，变量通过该指针来引用实例。
> \3) 一个是值COPY，一个是地址COPY。